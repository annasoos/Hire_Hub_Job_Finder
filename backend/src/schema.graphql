type Query {
	feed(input: FeedInput): Feed!
	ownListings: Feed!
	favourites: Feed!
}

type Feed {
	jobs: [Job!]!
	count: Int!
}

input FeedFilters {
	position: String
	location: String
	company: String
	isJunior: Boolean
}

input FeedInput {
	filter: FeedFilters,
	skip: Int,
	take: Int,
	orderBy: FeedOrderBy
}

input FeedOrderBy {
  createdAt: Sort
}

enum Sort {
  asc
  desc
}

type Mutation {
	post(position: String!, level: String!,	location: String!,	company: String!,	skills: String!,	description: String!): Job!
	signup(firstName: String!, lastName: String!, email: String!, password: String!): AuthPayload
  login(email: String!, password: String!): AuthPayload
	like(jobId: ID!): Like
	deleteListing(jobId: ID!): Delete!
	updateListing(jobId: ID!, level: String!,	skills: String!, description: String!): UpdateJob!
	updateUser(userId: ID!, firstName: String!, lastName: String!, email: String!, password: String!): UpdateUser!
}

# Subscriptions are a GraphQL feature that allows a server to send data to its clients when a specific event happens.
type Subscription {
	newJob: Job!
	deleteJob: Job!
	updateJob: Job!
}

type User {
	id: ID! # generated by the server
	firstName: String!
	lastName: String!
	email: String!
	password: String!
	posts: [Job!]!
	likes: [Like!]!
}

type Job {
	id: ID!
	position: String!
	level: String
	location: String!
	company: String!
	skills: String!
	description: String!
	creator: User! # the relation between User and Job should be bi-directional
	createdAt: String!
	likes: [Like!]!
}

type AuthPayload {
  token: String
  user: User
	message: String
}

type Like {
  id: ID!
  job: Job!
  user: User!
}

type Delete {
	deleteJob: Job!
	deletedLikesCount: Int
	message: String!
}

type UpdateJob {
	updateJob: Job!
	message: String!
}

type UpdateUser {
	updateUserData: User!
	message: String!
}